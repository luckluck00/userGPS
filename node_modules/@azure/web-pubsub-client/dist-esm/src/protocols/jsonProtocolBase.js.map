{"version":3,"file":"jsonProtocolBase.js","sourceRoot":"","sources":["../../../src/protocols/jsonProtocolBase.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  AckMessage,\n  ConnectedMessage,\n  DisconnectedMessage,\n  GroupDataMessage,\n  ServerDataMessage,\n  WebPubSubDataType,\n  WebPubSubMessage,\n} from \"../models/messages\";\nimport { JSONTypes } from \"../webPubSubClient\";\nimport { Buffer } from \"buffer\";\n\nexport function parseMessages(input: string): WebPubSubMessage | null {\n  // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\n  if (typeof input !== \"string\") {\n    throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\n  }\n\n  if (!input) {\n    throw new Error(\"No input\");\n  }\n\n  const parsedMessage = JSON.parse(input);\n  const typedMessage = parsedMessage as { type: string; from: string; event: string };\n  let returnMessage: WebPubSubMessage;\n\n  if (typedMessage.type === \"system\") {\n    if (typedMessage.event === \"connected\") {\n      returnMessage = { ...parsedMessage, kind: \"connected\" } as ConnectedMessage;\n    } else if (typedMessage.event === \"disconnected\") {\n      returnMessage = { ...parsedMessage, kind: \"disconnected\" } as DisconnectedMessage;\n    } else {\n      // Forward compatible\n      return null;\n    }\n  } else if (typedMessage.type === \"message\") {\n    if (typedMessage.from === \"group\") {\n      const data = parsePayload(parsedMessage.data, parsedMessage.dataType as WebPubSubDataType);\n      if (data === null) {\n        return null;\n      }\n      returnMessage = { ...parsedMessage, data: data, kind: \"groupData\" } as GroupDataMessage;\n    } else if (typedMessage.from === \"server\") {\n      const data = parsePayload(parsedMessage.data, parsedMessage.dataType as WebPubSubDataType);\n      if (data === null) {\n        return null;\n      }\n      returnMessage = {\n        ...parsedMessage,\n        data: data,\n        kind: \"serverData\",\n      } as ServerDataMessage;\n    } else {\n      // Forward compatible\n      return null;\n    }\n  } else if (typedMessage.type === \"ack\") {\n    returnMessage = { ...parsedMessage, kind: \"ack\" } as AckMessage;\n  } else {\n    // Forward compatible\n    return null;\n  }\n  return returnMessage;\n}\n\nexport function writeMessage(message: WebPubSubMessage): string {\n  let data: any;\n  switch (message.kind) {\n    case \"joinGroup\": {\n      data = { type: \"joinGroup\", group: message.group, ackId: message.ackId } as JoinGroupData;\n      break;\n    }\n    case \"leaveGroup\": {\n      data = { type: \"leaveGroup\", group: message.group, ackId: message.ackId } as LeaveGroupData;\n      break;\n    }\n    case \"sendEvent\": {\n      data = {\n        type: \"event\",\n        event: message.event,\n        ackId: message.ackId,\n        dataType: message.dataType,\n        data: getPayload(message.data, message.dataType),\n      } as SendEventData;\n      break;\n    }\n    case \"sendToGroup\": {\n      data = {\n        type: \"sendToGroup\",\n        group: message.group,\n        ackId: message.ackId,\n        dataType: message.dataType,\n        data: getPayload(message.data, message.dataType),\n        noEcho: message.noEcho,\n      } as SendToGroupData;\n      break;\n    }\n    case \"sequenceAck\": {\n      data = { type: \"sequenceAck\", sequenceId: message.sequenceId } as SequenceAckData;\n      break;\n    }\n    default: {\n      throw new Error(`Unsupported type: ${message.kind}`);\n    }\n  }\n\n  return JSON.stringify(data);\n}\n\ninterface JoinGroupData {\n  readonly type: \"joinGroup\";\n  group: string;\n  ackId?: number;\n}\n\ninterface LeaveGroupData {\n  readonly type: \"leaveGroup\";\n  group: string;\n  ackId?: number;\n}\n\ninterface SendToGroupData {\n  readonly type: \"sendToGroup\";\n  group: string;\n  ackId?: number;\n  dataType: WebPubSubDataType;\n  data: any;\n  noEcho: boolean;\n}\n\ninterface SendEventData {\n  readonly type: \"event\";\n  ackId?: number;\n  dataType: WebPubSubDataType;\n  data: any;\n  event: string;\n}\n\ninterface SequenceAckData {\n  readonly type: \"sequenceAck\";\n  sequenceId: number;\n}\n\nfunction getPayload(data: JSONTypes | ArrayBuffer, dataType: WebPubSubDataType): any {\n  switch (dataType) {\n    case \"text\": {\n      if (typeof data !== \"string\") {\n        throw new TypeError(\"Message must be a string.\");\n      }\n      return data;\n    }\n    case \"json\": {\n      return data;\n    }\n    case \"binary\":\n    case \"protobuf\": {\n      if (data instanceof ArrayBuffer) {\n        return Buffer.from(data).toString(\"base64\");\n      }\n      throw new TypeError(\"Message must be a ArrayBuffer\");\n    }\n  }\n}\n\nfunction parsePayload(data: any, dataType: string): JSONTypes | ArrayBuffer | null {\n  if (dataType === \"text\") {\n    if (typeof data !== \"string\") {\n      throw new TypeError(\"Message must be a string when dataType is text\");\n    }\n    return data as string;\n  } else if (dataType === \"json\") {\n    return data as JSONTypes;\n  } else if (dataType === \"binary\" || dataType === \"protobuf\") {\n    const buf = Buffer.from(data as string, \"base64\");\n    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength) as ArrayBuffer;\n  } else {\n    // Forward compatible\n    return null;\n  }\n}\n"]}